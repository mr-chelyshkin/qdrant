package main

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/go-openapi/loads"
	"github.com/go-openapi/spec"
)

const (
	openapiFileRelativePath = "../.tmpl/openapi.yaml"
	openapiSpecPath         = "../gen/apispec/apispec.go"
)

const specTemplate = `// Code generated by openapi generator; DO NOT EDIT.
package apispec

type routeInfo struct {
	Path   string ` + "`json:\"path\"`" + `
	Method string ` + "`json:\"method\"`" + `
}

var routes = map[string]routeInfo{
	{{- range $operationID, $route := .Data }}
	"{{ $operationID }}": {
		Path:   "{{ $route.Path }}",
		Method: "{{ $route.Method }}",
	},
	{{- end }}
}

// GetRoutes returns routes data
func GetRoutes() map[string]interface{} {
	return map[string]interface{}{
		"data": routes,
	}
}
`

type routeInfo struct {
	Path   string `json:"path"`
	Method string `json:"method"`
}

func main() {
	rootDir, err := filepath.Abs(".")
	if err != nil {
		panic(fmt.Sprintf("Cannot find root directory: %v", err))
	}

	doc, err := loads.Spec(filepath.Join(rootDir, openapiFileRelativePath))
	if err != nil {
		panic(fmt.Sprintf("Failed to load spec: %v", err))
	}

	var (
		routes  = make(map[string]routeInfo)
		swagger = doc.Spec()
	)
	if swagger.Paths != nil {
		for path, pathItem := range swagger.Paths.Paths {
			methods := []struct {
				operation *spec.Operation
				method    string
			}{
				{pathItem.Get, "GET"},
				{pathItem.Post, "POST"},
				{pathItem.Put, "PUT"},
				{pathItem.Delete, "DELETE"},
				{pathItem.Patch, "PATCH"},
			}

			for _, m := range methods {
				if m.operation != nil && m.operation.ID != "" {
					routes[m.operation.ID] = routeInfo{
						Path:   path,
						Method: m.method,
					}
				}
			}
		}
	}

	result := struct {
		Data map[string]routeInfo
	}{
		Data: routes,
	}

	tmpl, err := template.New("spec").Parse(specTemplate)
	if err != nil {
		panic(fmt.Sprintf("Failed to parse template: %v", err))
	}

	outputPath := filepath.Join(rootDir, openapiSpecPath)
	if err = os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		panic(fmt.Sprintf("Failed to create directory: %v", err))
	}

	f, err := os.Create(outputPath)
	if err != nil {
		panic(fmt.Sprintf("Failed to create spec file: %v", err))
	}
	defer f.Close()

	if err = tmpl.Execute(f, result); err != nil {
		panic(fmt.Sprintf("Failed to execute template: %v", err))
	}
	fmt.Printf("Successfully generated %s\n", outputPath)
}
